## 第九章 多媒体

### 一、通知：Notification

> 8.0 之后，新增通知渠道。每条消息通知都要属于一个对应的渠道

#### 创建通知渠道步骤

1. 通过NotificationManager对通知进行管理，通过调用Context的getSystemService方法获取。

   > getSystemService()方法接收一个字符串参数用于确定 获取系统的哪个服务

   ```kotlin
   val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
   ```

2. 通过NotificationChannel构建一个通知渠道，调用NotificationManager的createNotificationChannel()方法完成创建。（8.0之后新增，需要进行版本判断）

   ```kotlin
   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
   	val channel = NotificationChannel(channelId, channelName, importance)
    	manager.createNotificationChannel(channel)
   }
   ```

   > - 参1：渠道ID，任意设置，需要全局唯一。
   > - 参2：渠道名称，给用户查看，解释通道用途
   > - 参3：等级，IMPORTANCE_HIGH,IMPORTANCE_DEFAULT,IMPORTANCE_LOW,IMPORTANCE_MIN。用户可以手动更改通知通道等级。

#### 基本用法

通知可以在Activity创建，也可以在BroadcastReceiver或Service中创建，比较灵活。

##### 创建通知步骤：

1. 使用Builder构造器来创建Notification对象

   > 通过AndroidX库中的NotificationCompat类来创建

   ```kotlin
   val notification = NotificationCompat.Builder(context, channelId).build()
   ```

   可以通过在build方法之前设置属性。

   ```kotlin
   val notification = NotificationCompat.Builder(context, channelId)
    	.setContentTitle("This is content title")
    	.setContentText("This is content text")
    	.setSmallIcon(R.drawable.small_icon)//显示在系统状态栏上，只能使用纯alpha图层的图片进行设置
    	.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.large_icon))
    	.build()
   ```

   

2.  调用NotificationManager的notify()方法，让通知显示出来。参1：id，保证每个通知指定的Id都是不同的；参2：Notification对象。

   ```
   manager.notify(1,notification)
   ```

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityNotificationDemoBinding.inflate(layoutInflater)
        setContentView(binding.root)
        //1. 获取NotificationManager实例
        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O){
            //2. 创建ID为normal的通知渠道，创建通知渠道的diamagnetic只有第一次执行的时候才会创建，下次执行时，
            // 系统会检测到该通知渠道已经存在，不会重复创建
            val channel = NotificationChannel("normal","Normal",NotificationManager.IMPORTANCE_DEFAULT)
            manager.createNotificationChannel(channel)
        }
        binding.sendNotificationBtn.setOnClickListener {
            //3， Builder中的id需要和通知通道的保持一致，否则无法显示
            val notification = NotificationCompat.Builder(this,"normal")
                .setContentTitle("This is content title")
                .setContentText("this is content text")
                .setSmallIcon(R.drawable.testdemo2)
                .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.testdemo4))
                .build()
            manager.notify(1,notification)
        }
    }
```





##### 通知详细信息--PendingIntent

> 和Intent
>
> 共同点：指明某一个“意图”，用于启动Activity、启动Service以及发送广播。
>
> 不同点：Intent倾向于立即执行某个动作，PendingIntent倾向于在某个合适的实际执行某个动作。延迟的Intent

获取PendingIntent实例：

- getActivity()
- getBroadcast()
- getService()

> 参1：context
>
> 参2：0
>
> 参3：Intent对象
>
> 参4：PendingIntent: FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT。